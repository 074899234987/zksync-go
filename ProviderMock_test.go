// Code generated by mockery v1.0.0. DO NOT EDIT.

package zksync

import (
	big "math/big"

	common "github.com/ethereum/go-ethereum/common"
	mock "github.com/stretchr/testify/mock"
)

// ProviderMock is an autogenerated mock type for the Provider type
type ProviderMock struct {
	mock.Mock
}

// ContractAddress provides a mock function with given fields:
func (_m *ProviderMock) ContractAddress() (*ContractAddress, error) {
	ret := _m.Called()

	var r0 *ContractAddress
	if rf, ok := ret.Get(0).(func() *ContractAddress); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ContractAddress)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfirmationsForEthOpAmount provides a mock function with given fields:
func (_m *ProviderMock) GetConfirmationsForEthOpAmount() (*big.Int, error) {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEthOpInfo provides a mock function with given fields: priority
func (_m *ProviderMock) GetEthOpInfo(priority uint64) (*EthOpInfo, error) {
	ret := _m.Called(priority)

	var r0 *EthOpInfo
	if rf, ok := ret.Get(0).(func(uint64) *EthOpInfo); ok {
		r0 = rf(priority)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*EthOpInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(priority)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetState provides a mock function with given fields: address
func (_m *ProviderMock) GetState(address common.Address) (*AccountState, error) {
	ret := _m.Called(address)

	var r0 *AccountState
	if rf, ok := ret.Get(0).(func(common.Address) *AccountState); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*AccountState)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenPrice provides a mock function with given fields: token
func (_m *ProviderMock) GetTokenPrice(token *Token) (*big.Float, error) {
	ret := _m.Called(token)

	var r0 *big.Float
	if rf, ok := ret.Get(0).(func(*Token) *big.Float); ok {
		r0 = rf(token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*Token) error); ok {
		r1 = rf(token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokens provides a mock function with given fields:
func (_m *ProviderMock) GetTokens() (*Tokens, error) {
	ret := _m.Called()

	var r0 *Tokens
	if rf, ok := ret.Get(0).(func() *Tokens); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Tokens)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionDetails provides a mock function with given fields: txHash
func (_m *ProviderMock) GetTransactionDetails(txHash string) (*TransactionDetails, error) {
	ret := _m.Called(txHash)

	var r0 *TransactionDetails
	if rf, ok := ret.Get(0).(func(string) *TransactionDetails); ok {
		r0 = rf(txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TransactionDetails)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionFee provides a mock function with given fields: txType, address, token
func (_m *ProviderMock) GetTransactionFee(txType TransactionType, address common.Address, token *Token) (*TransactionFeeDetails, error) {
	ret := _m.Called(txType, address, token)

	var r0 *TransactionFeeDetails
	if rf, ok := ret.Get(0).(func(TransactionType, common.Address, *Token) *TransactionFeeDetails); ok {
		r0 = rf(txType, address, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TransactionFeeDetails)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(TransactionType, common.Address, *Token) error); ok {
		r1 = rf(txType, address, token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionsBatchFee provides a mock function with given fields: txTypes, addresses, token
func (_m *ProviderMock) GetTransactionsBatchFee(txTypes []TransactionType, addresses []common.Address, token *Token) (*TransactionFeeDetails, error) {
	ret := _m.Called(txTypes, addresses, token)

	var r0 *TransactionFeeDetails
	if rf, ok := ret.Get(0).(func([]TransactionType, []common.Address, *Token) *TransactionFeeDetails); ok {
		r0 = rf(txTypes, addresses, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TransactionFeeDetails)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]TransactionType, []common.Address, *Token) error); ok {
		r1 = rf(txTypes, addresses, token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitTx provides a mock function with given fields: signedTx, ethSignature, fastProcessing
func (_m *ProviderMock) SubmitTx(signedTx ZksTransaction, ethSignature *EthSignature, fastProcessing bool) (string, error) {
	ret := _m.Called(signedTx, ethSignature, fastProcessing)

	var r0 string
	if rf, ok := ret.Get(0).(func(ZksTransaction, *EthSignature, bool) string); ok {
		r0 = rf(signedTx, ethSignature, fastProcessing)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ZksTransaction, *EthSignature, bool) error); ok {
		r1 = rf(signedTx, ethSignature, fastProcessing)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitTxMultiSig provides a mock function with given fields: signedTx, ethSignatures
func (_m *ProviderMock) SubmitTxMultiSig(signedTx ZksTransaction, ethSignatures ...*EthSignature) (string, error) {
	_va := make([]interface{}, len(ethSignatures))
	for _i := range ethSignatures {
		_va[_i] = ethSignatures[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, signedTx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 string
	if rf, ok := ret.Get(0).(func(ZksTransaction, ...*EthSignature) string); ok {
		r0 = rf(signedTx, ethSignatures...)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ZksTransaction, ...*EthSignature) error); ok {
		r1 = rf(signedTx, ethSignatures...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitTxsBatch provides a mock function with given fields: signedTxs, ethSignature
func (_m *ProviderMock) SubmitTxsBatch(signedTxs []*SignedTransaction, ethSignature *EthSignature) ([]string, error) {
	ret := _m.Called(signedTxs, ethSignature)

	var r0 []string
	if rf, ok := ret.Get(0).(func([]*SignedTransaction, *EthSignature) []string); ok {
		r0 = rf(signedTxs, ethSignature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]*SignedTransaction, *EthSignature) error); ok {
		r1 = rf(signedTxs, ethSignature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTokenSet provides a mock function with given fields:
func (_m *ProviderMock) UpdateTokenSet() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
