// Code generated by mockery v1.0.0. DO NOT EDIT.

package zksync

import (
	big "math/big"

	common "github.com/ethereum/go-ethereum/common"
	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// EthProviderMock is an autogenerated mock type for the EthProvider type
type EthProviderMock struct {
	mock.Mock
}

// ApproveDeposits provides a mock function with given fields: token, limit, options
func (_m *EthProviderMock) ApproveDeposits(token *Token, limit *big.Int, options *GasOptions) (*types.Transaction, error) {
	ret := _m.Called(token, limit, options)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*Token, *big.Int, *GasOptions) *types.Transaction); ok {
		r0 = rf(token, limit, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*Token, *big.Int, *GasOptions) error); ok {
		r1 = rf(token, limit, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Deposit provides a mock function with given fields: token, amount, userAddress, options
func (_m *EthProviderMock) Deposit(token *Token, amount *big.Int, userAddress common.Address, options *GasOptions) (*types.Transaction, error) {
	ret := _m.Called(token, amount, userAddress, options)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*Token, *big.Int, common.Address, *GasOptions) *types.Transaction); ok {
		r0 = rf(token, amount, userAddress, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*Token, *big.Int, common.Address, *GasOptions) error); ok {
		r1 = rf(token, amount, userAddress, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FullExit provides a mock function with given fields: token, accountId, options
func (_m *EthProviderMock) FullExit(token *Token, accountId uint32, options *GasOptions) (*types.Transaction, error) {
	ret := _m.Called(token, accountId, options)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*Token, uint32, *GasOptions) *types.Transaction); ok {
		r0 = rf(token, accountId, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*Token, uint32, *GasOptions) error); ok {
		r1 = rf(token, accountId, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FullExitNFT provides a mock function with given fields: token, accountId, options
func (_m *EthProviderMock) FullExitNFT(token *NFT, accountId uint32, options *GasOptions) (*types.Transaction, error) {
	ret := _m.Called(token, accountId, options)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*NFT, uint32, *GasOptions) *types.Transaction); ok {
		r0 = rf(token, accountId, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*NFT, uint32, *GasOptions) error); ok {
		r1 = rf(token, accountId, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBalance provides a mock function with given fields: token
func (_m *EthProviderMock) GetBalance(token *Token) (*big.Int, error) {
	ret := _m.Called(token)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*Token) *big.Int); ok {
		r0 = rf(token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*Token) error); ok {
		r1 = rf(token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNonce provides a mock function with given fields:
func (_m *EthProviderMock) GetNonce() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsDepositApproved provides a mock function with given fields: token, userAddress, threshold
func (_m *EthProviderMock) IsDepositApproved(token *Token, userAddress common.Address, threshold *big.Int) (bool, error) {
	ret := _m.Called(token, userAddress, threshold)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*Token, common.Address, *big.Int) bool); ok {
		r0 = rf(token, userAddress, threshold)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*Token, common.Address, *big.Int) error); ok {
		r1 = rf(token, userAddress, threshold)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsOnChainAuthPubkeyHashSet provides a mock function with given fields: nonce
func (_m *EthProviderMock) IsOnChainAuthPubkeyHashSet(nonce uint32) (bool, error) {
	ret := _m.Called(nonce)

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint32) bool); ok {
		r0 = rf(nonce)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint32) error); ok {
		r1 = rf(nonce)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAuthPubkeyHash provides a mock function with given fields: pubKeyHash, zkNonce, options
func (_m *EthProviderMock) SetAuthPubkeyHash(pubKeyHash string, zkNonce uint32, options *GasOptions) (*types.Transaction, error) {
	ret := _m.Called(pubKeyHash, zkNonce, options)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(string, uint32, *GasOptions) *types.Transaction); ok {
		r0 = rf(pubKeyHash, zkNonce, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, uint32, *GasOptions) error); ok {
		r1 = rf(pubKeyHash, zkNonce, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
